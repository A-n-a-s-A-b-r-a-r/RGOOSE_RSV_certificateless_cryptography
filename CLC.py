"""
Certificateless Cryptography Module
----------------------------------
Implements certificateless public key cryptography with periodic key rotation.
"""

import os
import time
import json
import base64
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec, padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.backends import default_backend


class CertificatelessCrypto:
    """
    Implements certificateless cryptography model with key rotation capability.
    """
    def __init__(self, key_dir='./keys', rotation_interval=30):
        """
        Initialize the certificateless crypto system.
        
        Args:
            key_dir: Directory to store keys
            rotation_interval: Key rotation interval in seconds
        """
        self.key_dir = key_dir
        self.rotation_interval = rotation_interval
        self.last_rotation = 0
        self.private_key = None
        self.public_key = None
        self.system_params = None
        
        # Create key directory if it doesn't exist
        if not os.path.exists(key_dir):
            os.makedirs(key_dir)
        
        # Initialize system parameters
        self._initialize_system_params()
        
        # Generate initial keys
        self._rotate_keys()
    
    def _initialize_system_params(self):
        """Initialize system parameters for the cryptosystem"""
        # In a real implementation, these would be generated by a trusted authority
        # For this demo, we'll create a simple parameter set
        self.system_params = {
            'curve': 'secp256r1',
            'hash_algorithm': 'sha256',
            'kdf_info': b'certificateless_crypto_kdf'
        }
        
        # Save system parameters
        with open(os.path.join(self.key_dir, 'system_params.json'), 'w') as f:
            params_save = dict(self.system_params)
            params_save['kdf_info'] = base64.b64encode(self.system_params['kdf_info']).decode('utf-8')
            json.dump(params_save, f)
    
    def _rotate_keys(self, force=False):
        """
        Rotate keys if rotation interval has passed or if forced.
        
        Args:
            force: Force key rotation regardless of time interval
        """
        current_time = time.time()
        if force or (current_time - self.last_rotation >= self.rotation_interval):
            # Generate new key pair
            self.private_key = ec.generate_private_key(
                ec.SECP256R1(),
                default_backend()
            )
            self.public_key = self.private_key.public_key()
            
            # Save keys
            self._save_keys()
            
            # Update rotation timestamp
            self.last_rotation = current_time
            
            return True
        return False
    
    def _save_keys(self):
        """Save keys to the specified key directory"""
        # Save private key (normally this would be securely stored)
        private_key_pem = self.private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        # with open(os.path.join(self.key_dir, 'private_key.pem'), 'wb') as f:
        #     f.write(private_key_pem)
        
        # Save public key for sharing
        public_key_pem = self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        with open(os.path.join(self.key_dir, 'public_key.pem'), 'wb') as f:
            f.write(public_key_pem)
        
        # Save timestamp to track rotation
        with open(os.path.join(self.key_dir, 'key_timestamp.txt'), 'w') as f:
            f.write(str(self.last_rotation))
    
    def check_and_rotate_keys(self):
        """Check if keys need rotation and rotate if necessary"""
        return self._rotate_keys()
    
    def encrypt(self, data, recipient_public_key_pem=None):
        """
        Encrypt data using certificateless encryption.
        
        Args:
            data: Bytes to encrypt
            recipient_public_key_pem: Recipient's public key as PEM (optional)
        
        Returns:
            Dictionary containing encrypted data and metadata
        """
        # Check if keys need rotation
        self.check_and_rotate_keys()
        
        # Load recipient public key if provided, otherwise use own public key
        if recipient_public_key_pem:
            recipient_key = serialization.load_pem_public_key(
                recipient_public_key_pem,
                default_backend()
            )
        else:
            recipient_key = self.public_key
        
        # Generate ephemeral key pair
        ephemeral_private_key = ec.generate_private_key(
            ec.SECP256R1(),
            default_backend()
        )
        ephemeral_public_key = ephemeral_private_key.public_key()
        
        # Perform key agreement to establish shared secret
        shared_key = ephemeral_private_key.exchange(
            ec.ECDH(),
            recipient_key
        )
        
        shared_key_partial = ephemeral_private_key.exchange(ec.ECDH(), self.partial_key.public_key())
        combined_shared = shared_key + shared_key_partial
        
        # Derive encryption key using HKDF
        derived_key = HKDF(
            algorithm=hashes.SHA256(),
            length=32,
            salt=None,
            info=self.system_params['kdf_info'],
            backend=default_backend()
        ).derive(combined_shared)
        
        # Generate random IV
        iv = os.urandom(16)
        
        # Encrypt data
        encryptor = Cipher(
            algorithms.AES(derived_key),
            modes.GCM(iv),
            backend=default_backend()
        ).encryptor()
        
        ciphertext = encryptor.update(data) + encryptor.finalize()
        
        # Package the encrypted data with the ephemeral public key and metadata
        result = {
            'ciphertext': base64.b64encode(ciphertext).decode('utf-8'),
            'iv': base64.b64encode(iv).decode('utf-8'),
            'tag': base64.b64encode(encryptor.tag).decode('utf-8'),
            'ephemeral_key': base64.b64encode(
                ephemeral_public_key.public_bytes(
                    encoding=serialization.Encoding.DER,
                    format=serialization.PublicFormat.SubjectPublicKeyInfo
                )
            ).decode('utf-8'),
            'timestamp': self.last_rotation
        }
        
        return result
    
    def decrypt(self, encrypted_data):
        """
        Decrypt data using certificateless decryption.
        
        Args:
            encrypted_data: Dictionary with encrypted data and metadata
        
        Returns:
            Decrypted data as bytes
        """
        # Check if keys need rotation
        self.check_and_rotate_keys()
        
        # Extract components from encrypted data
        ciphertext = base64.b64decode(encrypted_data['ciphertext'])
        iv = base64.b64decode(encrypted_data['iv'])
        tag = base64.b64decode(encrypted_data['tag'])
        ephemeral_public_key_bytes = base64.b64decode(encrypted_data['ephemeral_key'])
        
        # Load ephemeral public key
        ephemeral_public_key = serialization.load_der_public_key(
            ephemeral_public_key_bytes,
            default_backend()
        )
        
        # Perform key agreement to establish shared secret
        shared_key = self.private_key.exchange(
            ec.ECDH(),
            ephemeral_public_key
        )
        shared_key_partial = self.partial_key.exchange(ec.ECDH(), ephemeral_public_key)
        combined_shared = shared_key + shared_key_partial

        
        # Derive decryption key using HKDF
        derived_key = HKDF(
            algorithm=hashes.SHA256(),
            length=32,
            salt=None,
            info=self.system_params['kdf_info'],
            backend=default_backend()
        ).derive(combined_shared)
        
        # Decrypt data
        decryptor = Cipher(
            algorithms.AES(derived_key),
            modes.GCM(iv, tag),
            backend=default_backend()
        ).decryptor()
        
        return decryptor.update(ciphertext) + decryptor.finalize()

    def encrypt_bytes(self, data, recipient_public_key_pem=None):
        """
        Encrypt byte data and return the result as bytes (for easier integration).
        
        Args:
            data: Bytes to encrypt
            recipient_public_key_pem: Recipient's public key as PEM (optional)
            
        Returns:
            Bytes containing the encrypted data
        """
        encrypted_dict = self.encrypt(data, recipient_public_key_pem)
        return json.dumps(encrypted_dict).encode('utf-8')
    
    def decrypt_bytes(self, encrypted_bytes):
        """
        Decrypt data from byte format.
        
        Args:
            encrypted_bytes: Bytes containing encrypted data in JSON format
            
        Returns:
            Decrypted data as bytes
        """
        encrypted_dict = json.loads(encrypted_bytes.decode('utf-8'))
        return self.decrypt(encrypted_dict)
    
    def get_public_key_pem(self):
        """Get current public key in PEM format"""
        return self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
    
    def load_public_key(self, key_path):
        """Load a public key from a file"""
        with open(key_path, 'rb') as f:
            public_key_pem = f.read()
            return serialization.load_pem_public_key(
                public_key_pem,
                backend=default_backend()
            )
            # In CertificatelessCrypto
    def initialize_with_partial_key(self, user_id: str, kgc):
        """
        Setup certificateless keys: combine KGC's partial private key and user's secret key.
        """
        self.user_id = user_id
        self.partial_key = kgc.generate_partial_private_key(user_id)
        self.user_secret = ec.generate_private_key(ec.SECP256R1(), default_backend())

        # Final private key: just use user secret for ECDH (partial key adds external trust)
        self.private_key = self.user_secret
        self.public_key = self.user_secret.public_key()
        self._save_keys()
        self.last_rotation = time.time()


# Helper functions for quick use
def create_crypto_instance(key_dir='./keys', rotation_interval=30):
    """Create a new certificateless crypto instance"""
    return CertificatelessCrypto(key_dir, rotation_interval)

def get_public_key(key_path):
    """Load a public key from a file"""
    with open(key_path, 'rb') as f:
        public_key_pem = f.read()
        return public_key_pem

def get_timestamp():
    """Load a public key from a file"""
    with open('keys/key_timestamp.txt', 'rb') as f:
        key_timestamp = f.read()
        return key_timestamp

